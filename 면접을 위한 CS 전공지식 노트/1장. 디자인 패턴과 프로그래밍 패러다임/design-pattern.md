# 디자인 패턴

디자인 패턴 : 프로그램 설계할 때 발생했던 문제들을 객체 간 상호 관계 등을 이용해 해결할 수 있도록 하나의 '규약' 형태로 만든 것.

## 싱글톤 패턴
하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴. <BR>
하나의 클래스를 기반으로 여러 개 인스턴스를 만들 수 있지만 그렇게 안 하고
클래스 하나 당 무조건 인스턴스 하나를 기반으로 로직 만드는데 사용

-> 보통 데이터베이스 연결 모듈에 많이 사용됨.

장점 : 
1. 하나의 인스턴스 생성 후 다른 모듈에 공유하며 사용하기 때문에
인스턴스 생성 비용이 줄어든다.
2. 사용 하기 쉽고 실용적이다.
<BR><BR>
단점 : 
1. 의존성이 높아진다. 이때 의존성이란 A가 B에 의존성이 있다는 건 B의 변경 사항에 대해 A 또한 변해야 된다는 걸 의미한다.
2. 또한 TDD 할 때 걸림돌이 된다. TDD 를 할 때 단위 테스트를 주로 하는데, 단위 테스트는 서로 독립적이어야 하며 테스트를 어떤 순서로든 실행할 수 있어야 한다.
하지만 싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로 각 테스트마다 독립적인 인스턴스르 만들기 어렵다.
3. 모듈 간의 결합을 강하게 만들 수 있다.
   - 이는 의존성 주입 (DI)을 통해 모듈 간 결합을 조금 느슨하게 만들어 해결할 수 있다. 
   - 의존성 주입이란 메인 모듈이 직접 다른 하위 모듈에 대해 의존성을 주기 보단 중간에 의존성 주입자가 이 부분을 가로채 간접적으로 의존성을 주입하는 방법이다.
   - 의존성 주입 원칙 : 상위 모듈은 하위 모듈에서 어떤 것도 가져오지 말아야 하며, 둘다 추상화에 의존해야 하며, 이때 추상화는 세부 사항에 의존하지 말아야 한다.
   - 의존성 주입을 통해 모듈들을 쉽게 교체할 수 있는 구조가 되어 테스팅이 수월하고 마이그레이션하기도 수월하다. 또한 구현 시 추상화 레이어를 넣고 이를 기반으로 구현체를 넣어주기 때문에 애플리케이션 의존성 바얗ㅇ이 일관되고 쉽게 추론 가능하며 모듈 간 관계가 더 명확해진다.
   - 단점으로는 모듈들이 더욱 분리되므로 클래스 수가 늘어나 복잡성이 증가될 수 있으며, 런타임 패널티가 발생할 수 있다.

이러한 싱글톤 패턴은 Node.js 에서 MongoDB 데이터베이스 연결 할 때 쓰는 mongoose 모듈에서 볼 수 있다.
mongoose의 데이터베이스 연결 시 쓰는 connect() 함수는 싱글톤 인스턴스를 반환한다.

예제
```
    Mongoose.prototype.connect = function(uri, options, callback){
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    const conn = _mongoose.connection;
    
    return _mongoose._promiseOrCallback(callback, cb => {
        conn.openUri(uri, options, err => {
            if(err != null) {
                return cb(err);
            }
            return cb(null, _mongoose);
            });
        });
    };    
```

Node.js 에서 MySQL 데이터베이스 연결 시에도 싱글톤 패턴이 사용된다.

## 팩토리 패턴

팩토리 패턴은 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴이자 상속 관계가 있는 두 클래스에 상위 클래스가 중요한 뼈대를 결정하고
하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴이다. <span style="color:gray">(레시피에 따라 다른 음료를 만들어내는 커피 머신..)</span>

상위 클래스, 하위 클래스 분리로 인해 느슨한 결합을 가지게 되며 상위 클래스에서는 인스턴스 생성 방식을 전혀 알 필요가 없기에 더 많은 유연성을 가질 수 있다.
객체 지향 생성 로직이 따로 떼어 있어 코드 리팩토링을 하더라도 한 곳만 하면 돼 유지 보수성이 늘어난다.

예제

자바스크립트에서 팩토리 패턴을 구현한다면 간단하게 `new Object()`로 구현할 수 있다.

```
const num = new Object(42)
const str = new Object('abc')
```
숫자를 전달하느냐, 문자를 전달하느냐에 따라 다른 타입의 객체를 생성하는 것을 볼 수 있다.
즉, 전달 받은 값에 따라 다른 객체를 생성하면서 인스턴스의 타입을 정한다.


## 전략 패턴

전략 패턴은 정책 패턴이라고도 하며, 객체의 행위를 바꾸고 싶은 경우 직접 수정하지 않고 전략이라 부르는 '캡슐화한 알고리즘'을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴이다. 

예제

passport 의 전략 패턴 : <BR>
passport 는 Node.js 에서 인증 모듈을 구현할 때 쓰는 미들웨어 라이브러리로,
여러가지 전략을 기반으로 인증할 수 있게 한다.
LocalStrategy 전략과 OAuth 전략 등을 지원한다.

## 옵저버 패턴

옵저버 패턴은 주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴이다.

또한 옵저버 패턴은 주로 이벤트 기반 시스템을 사용하며 MVC(Model-View-Controller) 패턴에도 사용된다.

옵저버 패턴의 예시로는 트위터가 있다.

예시

프론트엔드에 많이 사용되는 프레임워크 Vue.js 3.0 에서 ref나 reactive 로 정의하면 해당 값이 변경되었을 때 자동으로 DOM에 있는 값이 변경되는데,
이는 앞서 설명한 프록시 객체를 이용한 옵저버 패턴을 이용해 구현한 것이다.

## 프록시 패턴과 프록시 서버

프록시 객체 : 어떠한 대성의 기본적인 동작 (속성 접근, 할당, 순회, 열거, 함수 호출 등)의 작업을 가로챌 수 있는 객체를 뜻하며,
자바스크립트에서 프록시 객체는 두 개의 매개변수를 가진다.
   - target: 프록시 할 대상
   - handler: target 동작을 가로 채고 어떠한 동작을 할 것인지가 설정되어 있는 함수

이러한 프록시 객체는 프록시 패턴이 녹아 들어가 있는 객체이다.

프록시 패턴은 대상 객체에 접근 하기 전 그 접근에 대해 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴이다.

이를 통해 객체의 속성, 변환 등을 보완 하며 보안, 데이터 검증, 캐싱, 로깅에 사용된다.
이는 앞서 설명한 프록시 객체로 쓰이기도 하지만 프록시 서버로도 활용이 된다.

```
프록시 서버에서의 캐싱

캐시 안에 정보를 담아두고, 캐시 안에 있는 정보를 요구하는 요청에 대해 다시 저 멀리 있는 원격 서버에 요청하지 않고 캐시 안에 있는 데이터를 활용하는 것을 말한다.
이를 통해 불필요하게 외부와 연결하지 않기 때문에 트래픽을 줄일 수 있다는 장점이 있다.
```

### 프록시 서버 
프록시 서버는 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램을 가리킨다.

   - 프록시 서버로 쓰는 nginx
      : nginx는 비동기 이벤트 기반의 구조와 다수의 연결을 효과적으로 처리 가능한 웹 서버이며, 주로 서버 앞단의 프록시 서버로 활용된다.
      : Node.js 에서 서버를 구축할 때 nginx 를 앞단에 둠으로써 익명 사용자가 직접적으로 서버에 접근하는 것을 차단하고, 간접적으로 한 단계를 더 거치게 만들어 보안을 강화할 수 있고, 버퍼 오버플로우 취약점을 예방할 수 있다.
      : nginx 를 프록시 서버로 둬서 실제 포트를 숨길 수 있고 정적 자원을 gzip 압축하거나 메인 서버 앞단에서 로깅할 수도 있다.
   
   - 프록시 서버로 쓰는 CloudFlare
      : CloudFlare 는 전 세계적으로 분산된 서버가 있고 이를 통해 어떠한 시스템의 콘텐츠 전달을 빠르게 할 수 있는 CDN 서비스이다. 
      이때, CDN 이란 각 사용자가 인터넷에 접속하는 곳과 가까운 곳에서 컨텐츠를 캐싱 또는 배포하는 서버 네트워크를 말한다. 이를 통해 사용자가 웹 서버로부터 컨텐츠를 다운받는 시간을 줄일 수 있다.
      : CloudFlare는 웹 서버 앞단에 프록시 서버를 두어 DDOS 공격 방어나 HTTPS 구축에 쓰인다. 또 서비스를 배포한 이후에 해외에서 무언가 의심스러운 트래픽이 많이 발생하면 이 때문에 많은 클라우드 서비스 비용이 발생할 수도 있는데, 이때 CloudFlare 가 의심스러운 트래픽인지 먼저 판단해 CAPTCHA 등을 기반으로 일정 부분 막아주는 역할도 한다.
          : DDOS 공격방어
            : CloudFlare는 의심스러운 트래픽, 특히 사용자가 접속하는 게 아닌 시스템에서 오는 트래픽을 자동으로 차단해 DDOS 공격으로부터 보호한다. 이는 거대한 네트워크 용량과 캐싱 전략으로 소규모 DDOS 공격을 막아내며 방화벽 대시보드도 제공한다.
          : HTTPS 구축
            : 서버에서 HTTPS 를 구축할 때 인증서를 기반으로 구축할 수도 있다. 다만, CloudFlare를 이용하면 별도의 인증서 설치 없이 손쉽게 구축 가능하다.

   - CORS 와 프론트엔드의 프록시 서버
      : CORS 는 서버가 웹 브라우저에서 리소스를 로드할 때 다른 오리진을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘이다.
      : 프론트엔드 개발 시 프론트엔드 서버를 만들어 백엔드와 통신 시 주로 CORS 에러를 마주하는데, 이를 해결하기 위해 프록시 서버를 만들기도 한다. 이때, 프록시 서버는 프론트엔드 서버에서 요청되는 오리진을 서버 포트번호로 변경한다.
      : 이를 통해 CORS 에러 해결은 물론, 다양한 API 서버와의 통신도 매끄럽게 할 수 있다.
   

## 이터레이터 패턴

이터레이터 패턴은 이터레이터를 사용해 컬렉션의 요소들에 접근하는 디자인 패턴이다.
이를 통해 순회할 수 있는 여러 가지 자료형의 구조와는 상관 없이 이터레이터라는 하나의 인터페이스로 순회가 가능하다.

예를 들어, 자바스크립트에서 다른 자료구조인 set과 map 임에도 똑같은 for a of b 라는 이터레이터 프로토콜을 통해 순회가 가능하다.
- 이터레이터 프로토콜 : 이터러블한 객체들을 순회할 때 쓰이는 규칙
- 이터러블한 객체 : 반복 가능한 객체로 배열을 일반화한 객체

## 노출모듈 패턴
노출 모듈 패턴은 즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴을 말한다.
자바스크립트에서는 접근제어자가 존재하지 않고 전역 범위 내에서 스크립트가 실행되기 때문에, 노출 패턴을 통해 private과 public 접근 제어자를 구현하기도 한다.

예시

노출모듈 패턴을 기반으로 만든 자바스크립트 모듈 방식으로 CJS 모듈 방식이 있다.

## MVC 패턴

MVC 패턴은 모델, 뷰, 컨트롤러로 이루어진 디자인 패턴이다.

애플리케이션의 구성 요소를 3가지 역할로 구분해 개발 프로세스에서 각각의 구성 요소에만 집중해 개발할 수 있다.

재사용성과 확장성이 용이하다는 장점이 있고, 애플리케이션이 복잡해질 수록 모델과 뷰의 관계가 복잡해지는 단점이 있다.

### 모델
모델은 애플리에키션의 데이터인 데이터베이스, 상수, 변수 등을 의미한다.

뷰에서 데이터를 생성/수정하면 컨트롤러를 통해 모델을 생성하거나 갱신한다.

### 뷰
뷰는 Inputbox, checkbox, textarea 등 사용자 인터페이스 요소를 나타낸다.
즉, 모델을 기반으로 사용자가 볼 수 있는 화면을 뜻한다.
모델이 가지고 있는 정보를 따로 저장하지 않아야 하며 단순히 화면에 표시하는 정보만 가지고 있어야 한다.
또 변경이 일어나면 컨트롤러에 이를 전달해야 한다.

### 컨트롤러
하나 이상의 모델이나 뷰를 잇는 다리 역할을 하며 이벤트 등 메인 로직을 담당한다.
또한 모델과 뷰의 생명주기도 관리하며, 모델과 뷰의 변경 통지를 받으면 이를 해석해 각각의 구성 요소에 해당 내용애 대해 알려준다.

- MVC 패턴의 예 : 스프링
    : 스프링의 WEB MVC는 웹서비스를 구축하는데 편리한 기능을 많이 제공한다. 
    : `@RequestParam`, `@RequestHeader`, `@PathVariable` 등의 애너테이션을 기반으로 사용자의 요청 값들을 쉽게 분석할 수 있으며 사용자의 요청이 유효한 요청인지를 쉽게 거를 수 있다.

## MVP 패턴
MVP 패턴은 MVC 패턴에서 파생되었으면 C에 해당하는 컨트롤러가 프레젠터(presenter)로 교체된 패턴이다.
뷰와 프레젠터는 일대일 관계이기 때문에 MVC 패턴보다 더 강한 결합을 가진 디자인 패턴이라고 볼 수 있다.

## MVVM 패턴

MVVM 패턴은 MVC 의 C에 해당하는 컨트롤러를 뷰모델로 바뀐 패턴이다.

여기서 뷰 모델은 뷰를 더 추상화한 계층이며, MVVM 패턴은 MVC 패턴과는 다르게 커멘드와 데이터 바인딩을 가지는 게 특징이다.
뷰와 뷰모델 사이에 양방향 데이터 바인딩을 지원하며 UI 를 별도의 코드 수정 없이 재사용할 수 있고 단위 테스팅하기 쉽다는 장점이 있다.

이때, 커멘드란 여러 가지 요소에 대한 처리를 하나의 액션으로 처리할 수 있게 하는 기법을 말하며,
데이터 바인딩이란 화면에 보이는 데이터와 웹 브라우저의 메모리 데이터를 일치시키는 기법으로,
뷰모델을 변경하면 뷰가 변경된다.

- MVVM 패턴의 예 : 뷰
  : Vue.js 는 반응형이 특징인 프런트엔드 프레임워크로, 예를 들어 watch와 computed 등으로 쉽게 반응형적인 값들을 구축할 수 있다.
    : 함수를 사용하지 않고 값 대입만으로 변수가 변경되며 양방향 바인딩, html을 토대로 컴포넌트를 구축할 수 있다는 점이 특징이다.
    : 재사용 가능한 컴포넌트 기반으로 UI를 구축할 수 있으며 BMW, 구글, 루이비통 등에서 사용한다.

