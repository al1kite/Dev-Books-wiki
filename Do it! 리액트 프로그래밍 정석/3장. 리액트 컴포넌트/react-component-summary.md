
# React Component

## 3-1 컴포넌트를 구성하는 JSX

리액트 엔진은 JSX 의 XML 구조를 분석하여 자바스크립트 함수 코드로 변환한다. React.createElement() 함수를 사용하여 객체 모델을 생성한다. → 선언형 화면 기술

## 3-2 컴포넌트와 구성 요소

컴포넌트 : 기존의 웹 프레임워크는 MVC 방식으로 정보, 화면, 구동 코드를 분리해 관리했다. 정보 담당을 컨트롤러, 화면 담당을 뷰, 구동 담당을 컨트롤러라고 부르는 것에서 MVC 용어 출발. 이 방식은 코드 관리를 효율적으로 할 수 있다는 장점이 있으나 각 요소의 의존성이 높아 재활용이 어렵다는 단점.

하지만 웹 사이트의 화면은 각 요소가 비슷하고 반복적으로 사용한 경우가 많다. 이 점을 착안하여 등장한 것이 컴포넌트. 블록이라고 생각하면 간편.  MVC의 뷰를 독립적으로 구성하여 재사용 할 수 있다.

참고 : 컴포넌트의 첫 글자는 대문자여야 하는데, 이는 기존 HTML 마크업과 구분하기 위해 지정되었다.

**컴포넌트 구성 요소 미리 살펴보기**

| 데이터 구성 요소 | 특징 |
| --- | --- |
| 프로퍼티 | 상위 컴포넌트에서 하위 컴포넌트로 전달되는 읽기 전용 데이터 |
| state | 컴포넌트의 상태를 저장하고 변경할 수 있는 데이터 |
| 컨텍스트 | 부모 컴포넌트에서 생성하여 모든 자식 컴포넌트에 전달하는 데이터 |

**컴포넌트에 데이터를 전달하는 프로퍼티**

프로퍼티는 상위 컴포넌트가 하위 컴포넌트에 값을 전달할 때 사용되며, 이때 프로퍼티 값은 수정할 수 없다는 특징이 있다. 프로퍼티는 상위 컴포넌트에서 하위 컴포넌트로만 전달되는 단방향으로 데이터가 흐르는 방식이다.

**프로퍼티의 다양한 사용 방법 알아보기**

```tsx
1. 문자열형 프로퍼티

프로퍼티의 자료형을 선언하는 방법은 리액트에서 제공하는 prop-types 를 이용하는 것이다. 

2. 숫자 혹은 boolean형 프로퍼티

프로퍼티에서 문자열을 전달할 때는 큰따옴표를, 숫자나 boolean 등의 값을 전달 할 때는 큰따옴표는 불가하고 중괄호를 사용한다.

객체 구조 분해 할당식

3. 배열, 객체, 노드, 함수형 프로퍼티
```

## 3-4 컴포넌트 상태 관리하기

프로퍼티의 특징은 ‘컴포넌트 내부에서 값을 바꿀 수 없다’ 는 것이다. 값을 바꿔야 하는 경우에는 state 를 사용한다.

**state 로 상태 관리하기**

state는 ‘값을 저장하거나 변경할 수 있는 객체’로 보통 버튼을 클릭하거나 값을 입력하는 등의 이벤트와 함께 사용된다. (ex. 버튼 누를 시 버튼 색 변경, 글씨 모양 변경) setTimeout() 을 통해 상태 시간 제어 가능.

<aside style="background-color: #404040; padding: 20px; border-radius: 10px">
💡 state 사용 시 주의 사항 <BR>     
1. 생성자에서 반드시 초기화 해야 한다. <BR>  
2. state 값을 변경할 때는 setState() 함수(상태 관리 함수)를 반드시 사용해야 한다. <BR>  
3. setState() 함수는 비동기로 처리 되며, setState() 코드 이후로 연결된 함수들의 실행이 완료된 시점에 화면 동기화 과정을 거친다. <BR>
</aside>

1. 생성자에서 반드시 초기화 해야 한다.

state 에 저장되는 객체를 초기화하지 않으면 내부 함수에서 state 값에 접근할 수 없다. 만약 마땅한 초깃값이 없으면 state 에 빈 객체라도 넣어야 한다. 그리고 state 에 저장되는 객체의 값은 직접 변경할 수 없다.

1. state 값은 setState() 함수로 변경해야 한다.

state 값을 직접 변경하면A 안 되는 이유는 render() 함수로 화면을 그려주는 시점은 리액트 엔진이 정한다.  즉, state 값을 직접 변경해도 render() 함수는 직접 호출되지 않는다. 하지만 setStatus() 함수를 호출해 state 값을 변경하면 리액트 엔진이 자동으로 render() 함수를 호출하므로 화면에 변경된 state 값을 새롭게 출력할 수 있다. 리액트 엔진은 setState() 함수로 state 값을 변경하면 몇 단계의 검증 과정을 거쳐 render 함수를 호출한다.

1. setStatus() 함수의 인자로 함수를 전달하면 이전 state 값을 쉽게 읽을 수 있다.

setState() 함수의 인자로 함수를 전달하면 이전 state 값을 따로 읽는 과정을 생략할 수 있다.

일반 함수와 화살표 함수를 setStatus() 함수의 인자로 전달하여 state 값을 변경하는 방법 익혀두기!

**클래스 인스턴스 변수와 forceUpdate() 함수로 state 관리하기**

꼭 setState() 함수로 state 를 관리할 필요는 없고 setStatus() 함수를 사용하는 이유는 리액트 엔진이 state 의 변경과 화면 동기화 과정을 처리해야 하기 때문. 만약 출력 검증 작업 없이 함수가 호출될 때마다 새롭게 화면을 출력하고 싶다면 클래스 인스턴스 변수와 화면을 강제로 출력해주는 forceUpdate() 함수를 사용하면 된다. 다만, forceUpdate() 는 리액트 성능에 제약이 있으므로 매번 새롭게 화면을 출력해야 하는 경우가 아니라면 가급적 사용하지 않기를 바란다.

## 3-5 컴포넌트 생명주기

컴포넌트의 생성부터 소멸까지의 과정을 컴포넌트 생명주기라고 부른다. 컴포넌트는 생명주기마다 함수를 가지고 있는데 이 함수들을 이용하면 특정 시점에 원하는 동작을 하도록 만들 수도 있다.

**생명 주기 함수 살펴보기**

생명주기 함수는 지금까지 실습에서 사용한 render() 함수를 포함해 총 8개의 함수가 있다. 생명주기 함수는 리액트 엔진에서 자동으로 호출된다. 즉 개발자가 마음대로 호출할 수 없다.

![life-cycle](https://velopert.com/wp-content/uploads/2016/03/Screenshot-from-2016-12-10-00-21-26-1.png)

컴포넌트 생성부터 생성 완료까지 4개의 생명주기 함수가 호출된다. 이 과정을 생성 과정이라고 부른다.

이후 생성 완료부터 갱신 완료까지 5개의 생명주기 함수가 호출된다. 이 과정을 갱신 과정이라고 부른다. 이때 갱신 과정은 shouldComponenetUpdate() 함수의 반환값에 따라 true 인 경우 이후 과정이 진행되고 false 인 경우 갱신 과정이 모두 생략된다.

갱신 완료부터 소멸 완료까지는 1개의 생명주기 함수가 호출되며 이 과정을 소멸 과정이라고 부른다.

**생성주기 함수**

1. constructor(props) 함수

constructor() 함수는 이름 그대로 ‘맨 처음에 생성될 때 한 번만 호출’ 되며 상태를 선언할 때 사용된다. constructor() 함수를 정의할 때는 항상 super() 함수를 가장 위에 호출해야 한다. super() 함수에는 프로퍼티와 생명 주기 상태 등을 초기화하는 중요한 과정을 포함하기 때문이다.

```tsx
...
constructor(props){
	super(props);
	// 이후 추가적인 state 데이터 혹은 변수를 선언한다.
} 
...
```

1. render() 함수

render 함수는 데이터가 변경되어 새 화면을 그려야 할 때 자동으로 호출되는 함수이다. render() 함수가 반환하는 JSX 를 화면에 그려준다.

1. static getDerivedStateFromProps(props, state) 함수

getDerivedStateFromProps() 함수는 정적 함수이다. 따라서 함수 안에서 this.props 나 this.state 와 같은 방법으로 프로퍼티나 state 값을 접근할 수 없다.

만약 각 값에 접근해야 하는 경우 반드시 인자로 전달된 props, state 를 이용해야 한다. 이때 props 는 상위 컴포넌트에서 전달된 값이며 state 는 현재 컴포넌트의 state 값이다.

이 함수는 상위 컴포넌트에서 전달 받은 프로퍼티로 state 값을 연동할 때 주로 사용되며 반환값으로 stae 를 변경한다.

1. componenetDidMount() 함수

render() 함수가 JSX 를 화면에 그린 이후에 호출되는 함수. 만약 컴포넌트가 화면에 모두 표현된 이후 해야하는 작업들은 여기에서 하면 된다.

**갱신과정 함수**

1. static getDerivedStateFromProps(props, state) 함수
2. shouldCompoenetUpdate(nextProps, nextState) 함수

프로퍼티를 변경하거나 setState() 함수를 호출해 state 값을 변경하면 화면을 새로 출력해야 하는지 판단하는 함수이다. 이 함수는 화면을 새로 출력할지 말지 판단하며 데이터 변화를 비교하는 작업을 포함하므로 리액트 성능에 영향을 많이 준다. 화면 변경을 위해 검증 작업을 해야하는 경우 사용하며, forceUpdate() 호출해 화면 출력 시 호출되지 않는다.

1. render() 함수
2. getSnapshotBeforeUpdate(prevProps, prevState) 함수

컴포넌트의 변경된 내용이 가상 화면에 완성된 이후 호출되는 함수이다. 이 함수는 컴포넌트가 화면에 실제로 출력되기 전에 호출되므로 화면에 출력될 엘리먼트의 크기, 스크롤 위치 등 DOM 정보에 접근할 때 사용한다.

1. componentDidUpdate(prevProps, prevState, snapshot) 함수

컴포넌트가 실제 화면에 출력된 이후 호출되는 함수. 부모 컴포넌트로부터 전달된 이전 프로퍼티(prevProps)와 이전 state 값(prevState)과 함께 getSnapshotBeforeUpdate() 함수에서 반환된 값(snapshot)을 인자로 전달받습니다. 이 값들을 이용하여 스크롤 위치를 옮기거나 커서를 이동시키는 등의 DOM 정보를 변경할 때 사용됩니다.

**소멸 과정 함수**

1. componenetWillUnmount() 함수

컴포넌트가 소멸되기 직전에 호출되는 함수입니다. 보통 컴포넌트에서 감시하고 있는 작업들을 해제할 때 필요한 함수입니다. 해제 작업이 생략되면 메모리 누수 현상이 발생해 웹 브라우저의 작동이 멈추기도 합니다.

## 3-6. 클래스형 컴포넌트

클래스형 컴포넌트는 리액트 생명주기 함수와 컴포넌트 구성 요소를 모두 포함하고 있다. 클래스형 컴포넌트는 두 종류의 클래스 (Component, PureComponent) 를 사용한다. 두 클래스의 차이점과 장단점을 비교해볼 예정.
**Component class**

프로퍼티, state 와 생명주기 함수가 들어있는 구조의 컴포넌트를 만들 때 사용. 항상 render() 함수를 호출한다.

**PureComponent**

Component 클래스를 상속받는 클래스로 shouldComponentUpdate() 함수를 ‘얕은 비교’ 하도록 재정의되었다. 즉, 얕은 비교를 통해 데이터가 변경된 경우에만 render() 함수를 호출한다.

<aside style="background-color: #404040; padding: 20px; border-radius: 10px">
💡 얕은 비교 shallowEqual(v1, v2) 란? <BR>     
내용물을 모두 비교하지 않고 내부 값 변경보다는 두개의 배열이 동일한 주소를 가르키고 있는지를 비교하여 상태값 반환. 비교 검사 작업이 성능에 영향을 미치기에 얕은 비교를 통해 새로 출력할지 여부 판단

</aside>

PureComponent와 불변 변수로 성능을 높일 수 있다.

## 3-7 함수형 컴포넌트 (SFC)

state 를 포함하지 않으며 데이터를 받아 출력할 컴포넌트를 반환한다. 이는 함수와 동일한 구조를 가지고 있어, 입력받은 프로퍼티와 컨텍스트를 이용해 화면에 출력해준다. 따라서 함수형 컴포넌트에는 클래스 선언이 없다. 그리고 state와 생명주기 함수를 사용할 수 없다. 단순한 UI 컴포넌트 제작에 사용.

## 3-8 배열 컴포넌트

map() 함수를 사용하면 배열로 저장된 데이터를 바로 JSX 로 변경할 수 있다. 배열 데이터를 컴포넌트의 프로퍼티에 전달하거나, 컴포넌트형태의 JSX 로도 변경 가능해 map() 함수를 응용하면 반복 작업을 손쉽게 할 수 있다.

배열 컴포넌트는 배열 요소의 개수만큼 반복하므로 성능에 영행을 많이 준다. 따라서 배열 컴포넌트에는 키값을 key 로 꼭 정의해줘야 한다. 키값 정의를 통해 출력한 배열 컴포넌트는 재출력시 리엑트 엔진이 재활용하여 성능이 높일 수 있기 때문.

**render() 함수에서 여러 개의 JSX 노드 반환하기**

render() 함수는 트리 구조의 노드를 반환한다. 리액트는 트리 구조의 노드 외에도 배열 구조의 노드를 반환할 수 있는데, 리액트 16.3 버전 이후 ‘의미 없는 노드 추가’ (React.Fragment) 가 가능해져 다음과 같은 코드가 가능하다.

```tsx
...
render(){
	return[1,2,3].map((num) -> (
			<input type="radio" name="option1" key={'${num}'} value={num} label={'${num}개'}/>
``));
}
...
```

## 3-9 컴포넌트에서 콜백 함수와 이벤트 처리하기

프로퍼티를 사용해 상위 컴포넌트의 데이터를 하위 컴포넌트에 전달할 수 있다는 것을 배웠다. 따라서 만약 하위 컴포넌트에서 프로퍼티를 변경할 시 프로퍼티 원본을 수정할 수 있는 함수를 하위 컴포넌트에 제공하면 된다.

콜백 함수란 정의된 위치에서 실행되지 않고, 이후 특정 상황(이벤트, 다른 함수 호출 등)에서 실행되는 함수를 말한다. 즉, 콜백 함수를 프로퍼티에 전달하면 된다.

**bind() 함수로 this 범위 오류 해결하기**

콜백 함수를 프로퍼티 데이터로 전달하는 경우 하위 컴포넌트에서 참조할 this 범위에 대한 오류를 주의해야 한다. this 범위 오류는 bind() 함수를 사용해 해결할 수 있다. 이때 bind() 함수는constructor()에 모아두면 매번 render() 함수를 호출할 때마다 새로 작성하지 않아도 된다.

**컴포넌트에서 DOM 객체 함수 사용하기**

컴포넌트에서 window.addEventListener() 함수와 같은 DOM 객체 함수를 사용하려면 DOM 객체를 컴포넌트 변수에 할당해야 한다. 이때 특수 프로퍼티 ref 를 사용한다. ref 프로퍼티는 document.gerElementById()가 반환하는 객체를 반환한다. 단, ref 프로퍼티는 DOM 객체 함수가 필요한 엘리먼트에 콜백 함수 형태로 전달된다.

**컴포넌트에서 DOM 이벤트 사용하기**

컴포넌트에서 출력된 특정 DOM 객체에 이벤트 컴포넌트가 반응하기 위해서는 DOM 이벤트 프로퍼티를 사용해야 한다. 이벤트 프로퍼티는 특수 프로퍼티로 콜백 함수 형태로 전달해 처리한다.

자주 쓰는 이벤트 이름과 DOM 이벤트 프로퍼티 정리 표

| 이벤트 이름 | 이벤트 호출 시점 | JSX DOM 이벤트 프로퍼티 |
| --- | --- | --- |
| click | 엘리먼트의 마우스나 키보드가 클릭될 때 | onClick |
| submit | 폼의 데이터가 전송될 때 | onSubmit |
| mouseover | 엘리먼트 위에서 마우스 커서가 움직일 때 | onMouseMove |
| keydown | 키보드 버튼이 눌렀을 때 | onKeyDown |
| keypress | 키보드 버튼 입력이 완료 되었을 때 | onKeyPress |

![oneway-flow](https://blog.kakaocdn.net/dn/PmVnu/btrCskG6fIW/g3WvpI3m2pDjK0LjpZ8BBK/img.png)