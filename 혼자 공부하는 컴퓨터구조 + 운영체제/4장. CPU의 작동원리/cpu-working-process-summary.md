# CPU의 작동 원리와 성능 향상 기법

<details>

<summary> 목차 펼치기 </summary>

  1-1 ALU와 제어 장치

  1-2 레지스터와 주소 지정 방식 : 스택 주소 지정 방식과 변위 주소 지정 방식

  1-3 명령어 사이클과 인터럽트

  2-1 빠른 CPU를 위한 설계 기법 : 클럭, 코어와 멀티코어, 스레드와 멀티스레드

  2-2 명령어 병렬 처리 기법 : 명령어 파이프라인, 슈퍼스칼라, 비순차적 명령어 처리

  2-3 CISC와 RISC : 명령어 집합, CISC 와 RISC

</details>


# CPU의 작동원리

## ALU 와 제어장치

### ALU


계산하는 부품으로 계산을 하기 위해서는 피연산자와 수행할 연산이 필요하다. 따라서 ALU는 레지스터를 통해 피연산자를 받아들이고, 제어장치로부터 수행할 연산을 알려주는 제어 신호를 받아들인다.
그렇게 수행한 결과값 (숫자, 문자, 혹은 메모리 주소) 은 메모리에 바로 저장되지 않고 일시적으로 레지스터에 저장된다. CPU가 메모리에 접근하는 속도보다 레지스터에 접근하는 속도가 훨씬 빠르기 때문이다.
더불어 ALU는 계산결과 뿐만 아니라 플래그라는 정보를 함께 보낸다.
플래그 : 연산결과에 대한 추가적인 상태 정보로 플래그 레지스터라는 레지스터에 저장된다.

- 부호플래그 : 연산한 결과의 부호값
- 제로플래그 : 연산 결과가 0인지 여부
- 캐리플래그 : 연산 결과 올림수나 빌림수 발생 여부
- 오버플로우플래그 : 오버플로우 발생 여부
- 인터럽트 플래그 : 인터럽트 가능 여부
- 슈퍼바이저 플래그 : 커널 모드로 실행 중인지, 사용자 모드로 실행 중인지 여부

### 제어장치


제어 신호 (컴퓨터 부품을 관리/작동 시키기 위한 일종의 전기 신호) 를 내보내고 명령어를 해석하는 부품.

- * 제어장치가 받아들이는 정보 **
1. 클럭 신호 : 컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위. 컴퓨터 부품들은 클럭이라는 박자에 맞춰 작동하게 된다.
2. 해석해야 할 명령어 : CPU가 해석해야 할 명령어가 저장되는 명령어 레지스터로부터 해석할 명령어를 받아들이고 해석한 뒤 제어 신호를 발생시켜 컴퓨터 부품들에게 수행해야 할 내용을 알려준다.
3. 플래그 레지스터 속 플래그 값 : 제어장치가 플래그 값을 받아들이고 참고해 제어 신호 발생
4. 시스템버스 (그 중 제어 버스로 전달된 제어신호) : 제어 신호는 CPU 뿐만 아니라 입출력장치를 비롯한 CPU 외부 장치도 발생시킬 수 있다.
   제어장치가 보내는 정보
- CPU 외부에 전달하는 제어 신호 : 제어 버스로 제어 신호를 보낸다. 제어 신호에는 크게 메모리에 전달하는 제어 신호와 입출력장치에 전달하는 제어신호가 있다. 제어장치가 메모리에 저장된 값을 읽거나 새로 쓰고 싶다면 메모리로, 입출력장치의 값을 읽거나 새로 쓰고 싶다면 입출력장치로 제어신호를 보낸다.
- CPU 내부에 전달하는 제어 신호 : ALU에 전달하는 제어신호와 레지스터에 전달하는 제어 신호가 있다. ALU에는 수행할 연산 지시를 위해, 레지스터에는 레지스터 간 데이터 이동이나 저장된 명령어 해석을 위해 보낸다.

## 레지스터

명령어와 데이터는 실행 전후 반드시 레지스터에 저장되기에 레지스터만 잘 관찰해도 프로그램의 실행 흐름을 알 수 있다.

**반드시 알아야 할 레지스터**

1. 프로그램 카운터 : 메모리에서 읽어 들일 명령어의 주소를 저장
2. 명령어 레지스터 : 해석할 명령어, 방금 메모리에서 읽어 들인 명령어. 제어장치는 명령어 레지스터 속 명령어를 읽고 해석한 후 제어 신호를 보낸다.
3. 메모리 주소 레지스터 : 메모리의 주소를 저장하는 레지스터로 CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때 거치게 된다
4. 메모리 버퍼 레지스터 : 메모리와 주고받을 값 (데이터, 명령어)을 저장하는 레지스터. 메모리에 쓰고 싶거나 전달 받은 값 (데이터 버스로 주고받을 값) 이면 거치게 된다.
5. 플래그 레지스터
6. 범용 레지스터 : 다양하고 일반적인 상황에서 자유롭게 사용. 데이터와 주소를 모두 저장할 수 있다.
7. 스택 포인터 : 주소 지정에 사용될 수 있는 특수한 레지스터로 스택 주소 지정 방식에 사용된다.
8. 베이스 레지스터 : 주소 지정에 사용될 수 있는 특수한 레지스터로 프로그램 카운터와 함께 변위 주소 지정 방식에 사용된다.
- * 특정 레지스터를 이용한 주소 지정 방식 **
1. 스택 주소 지정 방식 : 스택과 스택 포인터를 이용한 주소 지정 방식. 스택은 가장 최근에 저장된 값부터 꺼낼 수 있는데, 스택 포인터란 스택의 꼭대기인 가장 마지막으로 저장된 값의 위치를 저장하는 레지스터이다. 이때 스택은 메모리 안 스택 영역으로 정해진 영역에 존재한다.
2. 변위 주소 지정 방식 : 명령어는 연산 코드와 오퍼랜드로 이루어져 있는데, 이 오퍼랜드 필드에는 메모리 주소가 담길 때도 있다. 이때 오퍼랜드 변위와 특정 레지스터 값을 더해 유효 주소를 얻어내는 방식이 변위 주소 지정 방식이다. 이때, 변위 주소 지정 방식은 오퍼랜드 필드의 주소와 어떤 레지스터를 더하는지에 따라 상대 주소 지정 방식과 베이스 레지스터 주소 지정 방식으로 나뉜다. 그 외에도 다양한 방식 존재.
- 상대 주소 지정 방식 : 오퍼랜드와 카운터 값을 더해 유효 주소를 얻는 방식
- 베이스 레지스터 주소 지정 방식 : 오퍼랜드와 베이스 레지스터의 값을 더해 유효 주소를 얻는 방식

## 명령어 사이클과 인터럽트

명령어 사이클 : 명령어를 처리하는 정형화된 흐름. 프로그램 속 각각 명령어들은 일정한 주기가 반복되며 실행되는데 이 주기를 의미.

- 인출사이클 : 메모리에 있는 명령어를 CPU로 가져오는 단계
- 실행사이클 : CPU로 가져온 명령어를 실행하는 단계
- 간접사이클 : CPU로 가져온 명령어를 실행하기 위해 다시 메모리를 접근

인터럽트 : 간혹 이 흐름이 끊어지는 상황이 발생. CPU의 작업을 방해하는 신호.

- 동기 인터럽트 : CPU에 의해 발생하는 인터럽트 (예외)
- 비동기 인터럽트 : 주로 입출력장치에 의해 발생하는 인터럽트 (하드웨어 인터럽트)
- * 인터럽트 관련 키워드 **
- 인터럽트 요청 신호 : CPU의 작업을 방해하는 인터럽트에 대한 요청
- 인터럽트 플래그 : 인터럽트 요청 신호를 받아들일지 무시할지 결정하는 비트
- 인터럽트 벡터 : 인터럽트 서비스 루틴의 시작 주소를 포함하는 인터럽트 서비스 루틴의 식별 정보
- 인터럽트 서비스 루틴 : 인터럽트를 처리하는 프로그램

# CPU 성능 향상 기법

## 빠른 CPU를 위한 설계 기법

### 클럭

클럭 속도는 헤르츠 단위로 측정한다. 이는 1초에 클럭이 몇 번 반복되는지를 나타내지만, 클럭 속도를 무한으로 높인다고 무조건 CPU가 빨라지는 건 아니다. 클럭 속도를 높이는 건 분면 CPU를 빠르게 만들지만, 클럭 속도만으로 CPU 성능을 올리는 건 한계가 있다. 클럭 속도를 무작정 높이면 발열 문제가 심각해진다.

### 코어와 멀티코어

CPU: 명령어를 실행하는 부품을 여러 개 포함하는 부품 (멀티코어 CPU, 멀티코어 프로세서)
코어 : 전통적 CPU 명칭의 의미로 명령어를 실행하는 부품

### 스레드와 멀티스레드

스레드 : 스레드는 실행 흐름의 단위로, CPU에서 사용되는 스레드와 프로그래밍에서 사용되는 스레드는 용례가 다르다.

- 하드웨어적 스레드 (논리 프로세서) : CPU에서 사용되는 하드웨어적 스레드는 하나의 코어를 동시에 처리하는 명령어 단위를 의미한다. 하나의 코어로 여러 명령어를 동시에 처리하는 CPU를 멀티스레드 프로세서, 멀티스레드 CPU 라고 명칭한다.
- 소프트웨어적 스레드 : 소프트웨어적 스레드는 하나의 프로그램에서 독립적으로 실행되는 단위의 의미로 기능을 작동시키는 코드를 메모리에서 나눠 각각의 스레드로 만들면 동시 실행이 가능하다.

멀티스레드 프로세서 설계의 핵심은 레지스터이다. 여러 개의 명령어를 동시에 처리 가능하도록 만들려면 명령어 처리에 필요한 레지스터를 여러 개 가지고 있으면 된다.

## 명령어 병렬 처리 기법

### 명령어 파이프라인

명령어 처리 과정을 클럭 단위로 나누어 보면 일반적으로 다음과 같이 나눌 수 있다.

1. 명령어 인출
2. 명령어 해석
3. 명령어 실행
4. 결과 저장
   여기서 중요한 점은 같은 단계가 겹치지 않는다면 CPU는 각 단계를 동시에 실행할 수 있다는 것이다. 마치 공장 생산 라인과 같이 명령어들을 명령어 파이프 라인에 넣고 동시에 처리하는 기법을 명령어 파이프라이닝이라고 한다.
- * 파이프라인 위험 **
1. 데이터 위험 : 데이터 의존성에 의해 발생한다. 모든 명령어를 동시에 처리할 수 없고, 이전 명령어를 끝까지 실행해야만 실행할 수 있는 명령어가 존재한다. 이를 무작정 동시에 실행하려 하면 파이프라인이 제대로 작동하지 않을 수 있다.
2. 제어 위험 : 분기 등으로 인한 프로그램 카운터의 갑작스러운 변화에 의해 발생한다. 프로그램 실행 흐름이 바뀌어 명령어가 실행되면서 프로그램 카운터 값에 갑작스러운 변화가 생긴다면 기존에 명령어 파이프라인에 가지고 와 처리 중이던 명령어가 쓸모가 없어진다.
3. 구조적 위험 : 명령어들이 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 CPU 부품을 사용하려 할 때 자원 위험이 발생하게 된다.

### 슈퍼스칼라

파이프라이닝은 단일 파이프라인으로도 구현이 가능하지만 오늘날 대부분 CPU에서는 여러 개의 파이프 라인을 사용하고, 이를 슈퍼스칼라라 명명한다. 슈퍼스칼라 프로세서 (CPU) 는 매 클럭 주기마다 동시에 여러 명령어를 인출, 실행할 수 있다. 가령 위의 멀티스레드 프로세서는 한 번에 여러 명령어를 인출, 해석, 실행할 수 있기에 슈퍼스칼라 구조를 사용할 수 있다.

### 비순차적 명령어 처리

명령어의 합법적 새치기. 파이프라인 위험과 같은 예상치 못한 문제들로 인해 명령어가 곧바로 처리되지 못하는 경우 순차적으로만 처리한다면 명령어 파이프라인이 멈추게 된다. 이때 실행 순서를 바꿔 실행하면 더욱 효율적으로 처리할 수 있다.

## CISC와 RISC

CPU가 이해할 수 있는 명령어의 모음을 명령어 집합 구조 (ISA) 라고 부른다. 즉, CPU마다 ISA가 다를 수 있다는 걸 의미한다. ISA는 일종의 CPU 언어인 셈이다. 명령어 병렬 처리 기법 도입에 유리한 ISA 의 현대 양대산맥이 CISC와 RISC이다.

### CISC

복잡한 명령어 집합을 활용하는 컴퓨터 (CPU) 의 약자로, 다양하고 강력한 기능의 명령어 집합을 활용하기에 명령어의 형태와 크기가 다양한 가변 길이 명령어를 활용한다. 따라서 적은 수의 명령으로 프로그램을 동작시키고 메모리를 절약할 수 있지만, 명령어의 규격화가 어려워 파이프라이닝이 어렵고, 대다수의 복잡한 명령어는 사용빈도가 낮다는 단점이 있다.

### RISC

CISC의 한계가 준 교훈은 다음과 같다.

1. 빠른 처리를 위해 명령어 파이프라인을 최대한으로 활용해야 한다. 이를 위해서는 명령어 길이와 수행시간이 짧고 규격화되어 있어야 한다.
2. 자주 쓰이는 명령어만 줄곧 사용하기에 복잡한 기능을 지원하는 명령어를 추가하기보다 자주 쓰이는 기본적인 명령어를 작고 빠르게 만드는 것이 중요하다.

이러한 원칙 하에 등장한 것이 RISC 이다. 이는 고정 길이 명령어를 활용하며 짧고 규격화된 명령어, 되도록 1클럭 내외로 실행하는 명령어를 지향한다. 또한 메모리 접근을 단순화, 최소화하는 대신 레지스터를 적극 활용한다. 따라서 CISC 보다 레지스터를 이용하는 연산도 많고 일반적인 경우 범용 레지스터 개수도 더 많고, 사용 가능한 명령어 개수가 CISC보다 더 적기에 많은 명령으로 프로그램을 작동시킨다.